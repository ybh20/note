# GO

### 1.1	go

go语言是一门静态编译型的语言，而不是动态解释型的。go语言的编译速度非常快，明显要快过其他同类型语言，比如 c 和 c++。

### 1.2	变量

变量的定义方式

![image-20221024184359882](C:\Users\86131\AppData\Roaming\Typora\typora-user-images\image-20221024184359882.png)

加号的基本使用

![image-20221026183255689](C:\Users\86131\AppData\Roaming\Typora\typora-user-images\image-20221026183255689.png)

### 1.3	数据类型

![image-20221026185606055](C:\Users\86131\AppData\Roaming\Typora\typora-user-images\image-20221026185606055.png)

#### 1.3.1	字符串类型

**字符串就是一串固定长度的字符连接起来的字符序列。**Go的字符串是由单个字节连接起来的。

基本使用：

![image-20221029193950760](C:\Users\86131\AppData\Roaming\Typora\typora-user-images\image-20221029193950760.png)

#### 1.3.2	布尔类型

1）布尔类型数据只允许取 true 和 false 两个值

2）布尔类型只占用1个字节

3）布尔类型适用于逻辑运算，用于程序流程控制

#### 1.3	基本数据类型转换

go在不同类型的变量之间赋值时需要**显示转换**。也就是说go中数据类型**不能自动转换。**

基本语法：

![image-20221030175526868](C:\Users\86131\AppData\Roaming\Typora\typora-user-images\image-20221030175526868.png)

注意事项：

1. 被转换的是**变量储存的值**，变量本身的数据类型并没有变化。
2. 在转换中，将一个大的转换成小的时，当大的数据类型存储的值超过小的数据类型能存储的范围时，编译时不会报错，只是转换后的结果是按溢出处理，和我们期望的结果不一样。

#### 1.3	基本数据类型转和string的转换

1. 方式一：fmt.Sprintf()

   ![image-20221030183530329](C:\Users\86131\AppData\Roaming\Typora\typora-user-images\image-20221030183530329.png)

   方式二：使用 strconv 包的函数

#### 1.3 源码、反码、补码

1. 二进制的最高位是符号位，0表示正数，1表示负数
2. 正数的源码、反码、补码都一样
3. 负数的反码 = 它的源码符号位不变，其他位取反
4. 负数的补码 = 反码 + 1
5. 0 的反码、补码都是 0
6. 在计算机运行的时候，都是以**补码的方式运算**的

#### 1.3 位运算，按位与&，按位或|，按位异或^

- 按位与 &：两位全为1，结果为1，否则为0
- 按位或 |：两位有一个为1，结果为1，否则为0
- 按位异或 ^：两位一个为0，一个为1，结果为1，否则为0

#### 1.3 算术左移 <<，算术右移 >>

​	算术左移 << ：符号位不变，低位补 0

​	算术右移 >> ：低位溢出，符号位不变，并用符号位补溢出的高位

### 1.4 流程控制

​	在程序运行过程中，流程控制决定程序是如何执行的。

#### 	1、顺序控制

​		程序从上往下逐行执行，没有任何的判断和跳转

#### 	2、分支控制

​		**1、单分支**

​			基本语法

```go
if 条件表达式 {
    // 代码块
}
```

​		**2、双分支**

​			基本语法

```go
if 条件表达式 {
    // 代码块
} else {
    // 代码块
}
```
